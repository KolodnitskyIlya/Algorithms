'''
Нам дали отсортированный массив arr и также нам даются m запросов(числа x), на каждый запрос мы должны находить такое
максимальное число y, который содержится в arr и при этом y <= x (y -> max)

arr = [1, 1, 3, 4, 7, 8]
x = 6 -> y = 4
x = 7 -> y = 7

1) Можно пройтись по массиву(n длины) и для каждого m запроса x искать этот максимальный y - O(n * m)
max = 0
0 <= i < n
if arr[i] <= x:
    max = arr[i]
return max

2) Бинарный (монотонный) поиск (полуинтервалы, интервалы, отрезки(лучшее)) - O(m * log n)
нам дали какой-то x
2.1) нам дали отсортированный arr = [ _ _ _ _ | _ _ _ _]
                 рассмотрим середину массива (arr[mid]) и если оно <= x, то левая часть отрезка нам не нужна, нам нужна
                 правая часть и снова делим пополам [_ _ | _ _] , и вдруг получилось что arr[mid1] > x, то нам не нужна
                 правая часть отрезка и остается [_ | _] и также рассматриваем этот отрезок
                 Делаем эту итерацию пока длина отрезка не станет равна 1, дальше просто возвращаем это число
2.2) нам дали неотсортированный массив -> и не вкусно и грустно(
'''

#функция зависит от задачи (найти макс)
def ok(mid, arr, x):
    return arr[mid] <= x

arr = [1, 1, 3, 4, 7, 8]
l = 0
r = len(arr) - 1
ans = 0
x = 6
while l <= r:
    mid = (l + r) // 2
    if ok(mid, arr, x):
        # Вы хотите найти максимум или минимум
        # Если min то двигаем правую границу, иначе левую
        # r = mid - 1
        l = mid + 1
        ans = mid
    else:
        # l = mid + 1
        r = mid - 1
print('pos =', ans)
print('value =', arr[ans])